program = _{ SOI ~ code ~ EOI }

code = _{ NEWLINE* ~ (expr ~ ";"? ~ NEWLINE+)* ~ expr? }
// Expression(Generic)
expr = {
    assgmtExpr
  | keywords
  | functions
  | monadicExpr
  | dyadicExpr
  | value
  | terms
  | mathExpr
}
// Keywords
keywords = {
    forLoop
}

functions = {
    print
}

stmt    = {
    "const"
  | "let"
  | "for"
}
print   = { "print" ~ "(" ~ code ~ ")" }
forLoop = { stmt ~ ident ~ "in" ~ expr ~ NEWLINE* ~ "{" ~ code ~ "}" }

// expressions(Logic)
monadicExpr = { verb ~ expr }

dyadicExpr = { (monadicExpr | terms | number | string) ~ verb ~ expr }

// Math expression
mathExpr = { atom ~ (operators ~ atom)* }

// Terms
terms = { term+ }

term = _{ (objectProp | ident) | "(" ~ expr ~ ")" }

// Variables

modifier   = { "const" | "let" | "" }
assgmtExpr = { modifier ~ ident ~ "=" ~ expr }

verb = {
    plus
  | multiply
  | range
  | increment
  | decrement
  | and
  | or
  | not
  | lt
  | lte
  | gt
  | gte
  | eq
  | neq
  | objectAccess
}
// operators
plus         = { "+" }
multiply     = { "*" }
increment    = { "++" }
decrement    = { "--" }
range        = { ".." }
objectAccess = { "." }

// Logic operators
and = { "and" | "&&" }
or  = { "or" | "||" }
not = { "!" }
lt  = { "<" }
lte = { "<=" }
gt  = { ">" }
gte = { ">=" }
eq  = { "==" }
neq = { "!=" | "<>" }
// Math operators
operators = _{ add | subtract | multiply | divide | modulo }
add       =  { "+" }
subtract  =  { "-" }
divide    =  { "/" }
modulo    =  { "%" }

// Indentificators
ident = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// value types
value = { objectProp | object | array | string | mathExpr | boolean | null | ident }

// Simple

boolean = { "true" | "false" }
null    = { "null" }

// Could be a negative or positive number
number = { unary_minus? ~ numericChar }
// "negate" a number
unary_minus = { "-" }
// Define char that match a number
numericChar = @{ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) ~ (("." ~ ASCII_DIGIT*)? ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+))? }

primary = _{ number | "(" ~ expr ~ ")" }
atom    = _{ unary_minus? ~ primary }

string = @{ "\"" ~ ("\\\"" | "\\\\" | (!"\"" ~ ANY))* ~ "\"" }
// Complex types
object = {
    "{" ~ "}"
  | "{" ~ NEWLINE* ~ (pairMultiLine) ~ ("," ~ pairMultiLine)* ~ "}"
}

objectProp = { ident ~ objectAccess ~ (objectProp | ident) }

pairMultiLine = _{ NEWLINE* ~ (pair ~ ","? ~ NEWLINE+)* ~ pair? }
pair          =  { (ident | "\"" ~ ident ~ "\"") ~ ":" ~ code }

array = {
    "[" ~ NEWLINE* ~ "]"
  | "[" ~ NEWLINE* ~ (value) ~ ("," ~ (code))* ~ NEWLINE* ~ "]"
}

// We can't have SOI and EOI on expr directly, because it is used recursively (e.g. with parentheses)
// program = _{ SOI ~ expr ~ EOI }

WHITESPACE = _{ " " | "\t" }

COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }
